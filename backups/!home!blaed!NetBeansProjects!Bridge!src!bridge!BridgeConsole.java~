package bridge;

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * This class provides a terminal console interface to the Bridge
 * Crossing problem.
 * The user attempts to solve the problem, with invalid moves rejected,
 * and the user can quit at any time.
 * If a move is valid, the new state is displayed.
 * If the solution is found, a message is given showing the number of moves
 * attempted, and processing halts.
 * @author Blaed Johnston
 */
public class BridgeConsole {

    /**
       Creates a bridge problem console user interface.  An introduction
       is displayed, the move count is initialized, the initial state is
       displayed, the first move is solicited, and problem solution proceeds.
       @param problem the problem
     */
    public BridgeConsole(BridgeProblem problem) {
        moveCount = 0;
        
        while(problem.success() != true)
        {
            tryMove(problem);
            incrementMoveCount();
        }//end of while
        System.out.println("Congratulations! You solved the problem in " + moveCount + " moves!"
                + "\nYour total time was "+ problem.getCurrentState().getTimeSoFar() + " minutes!\n" );
    }

    /**
     * This method launches the console
     * @param args ignored
     */
    public static void main(String[] args) {
        new BridgeConsole(new BridgeProblem());
    }
    
    /** Reads in user input and returns it as an integer, tests for non-integer input*/
    private int getOption()
    {
        Scanner sc = new Scanner(System.in);
        try{
            int i = sc.nextInt();
            if(i <= 10 && i >= 0){
                return i;
            }
            else{
                System.out.println("Invalid entry, please choose another number");
                return getOption();
            }
        }
     catch(InputMismatchException a){
         System.out.println("Invalid input, please try again. \n");
         return getOption();
     }
    }
    
    /** Attempts to perform the move specified by the user, if valid updates the state of the problem
     @param BridgeProblem problem*/
    private void tryMove(BridgeProblem problem){
        int option = display(problem);
        BridgeState tester = getMove(option, problem).doMove(problem.getCurrentState());
        if(tester != null)
        {
            problem.setCurrentState(tester);
        }
        else
        {
            System.out.println("Invalid move, try again");
            tryMove(problem);
        }
    }
    
    /**Retrieves the move chosen by the user from list of valid moves. */
    private BridgeMove getMove(int i, BridgeProblem problem){
        if(i == 0){
            System.out.println("User quit.  You attempted " + moveCount + " moves");
            System.exit(0);
        }
        ArrayList<BridgeMove> moveList = problem.getMoves();
        boolean valid = true;
        while(true){
                return moveList.get(i-1);
        }
    }
    
    /** Displays the introduction(if necessary), interface and current state 
     * of the problem, return the integer choice of the user*/
    private int display(BridgeProblem problem){
     if(moveCount == 0){
         System.out.print(problem.getIntroduction());
     }
     System.out.print(problem.getCurrentState().toString());
     System.out.print(moveOptions);
     int option = getOption();
     return option;
    }
    
    /** Adds one to the attempted move tally*/
    private void incrementMoveCount(){
        moveCount++;
    }
    
    private int moveCount;
    private String moveOptions =  "  1. P1 crosses alone\n" +
     "  2. P2 crosses alone\n" +
     "  3. P5 crosses alone\n" +
     "  4. P10 crosses alone\n" +
     "  5. P1 crosses with P2\n" +
     "  6. P1 crosses with P5\n" +
     "  7. P1 crosses with P10\n" +
     "  8. P2 crosses with P5\n" +
     "  9. P2 crosses with P10\n"+
     " 10. P5 crosses with P10\n"+
      "\nChoose 1-10 (zero to quit): ";
}
